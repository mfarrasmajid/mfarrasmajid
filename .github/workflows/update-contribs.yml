name: Update contributed repos in README

on:
  workflow_dispatch:
  schedule:
    - cron: "0 0 * * 1" # every Monday 00:00 UTC â€” adjust as you like

permissions:
  contents: write

jobs:
  update:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Build contributed repos list (last 12 months)
        env:
          GH_LOGIN: ${{ github.actor }}
          # Use CONTRIBS_TOKEN if you want to include private repos (see notes below),
          # otherwise the default GITHUB_TOKEN is fine for public contributions.
          GH_TOKEN: ${{ secrets.CONTRIBS_TOKEN || github.token }}
        run: |
          set -Eeuo pipefail

          # Better error visibility
          trap 'echo "::error file=${BASH_SOURCE[0]},line=${LINENO}::Command failed: $BASH_COMMAND"' ERR

          FROM_DATE="$(date -u -d '1 year ago' +%Y-%m-%dT%H:%M:%SZ)"
          TO_DATE="$(date -u +%Y-%m-%dT%H:%M:%SZ)"
          N=100  # max repos per bucket; raise if you contribute to many repos

          # GraphQL: collect repos from commits, PRs, issues, and created repos within window
          cat > query.graphql <<'GRAPHQL'
          query($login:String!, $from:DateTime!, $to:DateTime!, $n:Int!) {
            user(login:$login) {
              login
              contributionsCollection(from:$from, to:$to) {
                commitContributionsByRepository(maxRepositories: $n) {
                  repository { nameWithOwner url isPrivate owner { login } }
                }
                pullRequestContributionsByRepository(maxRepositories: $n) {
                  repository { nameWithOwner url isPrivate owner { login } }
                }
                issueContributionsByRepository(maxRepositories: $n) {
                  repository { nameWithOwner url isPrivate owner { login } }
                }
                repositoryContributions(first: $n) {
                  nodes {
                    repository { nameWithOwner url isPrivate owner { login } }
                  }
                }
              }
            }
          }
          GRAPHQL

          RESP=$(jq -n \
              --rawfile q query.graphql \
              --arg login "$GH_LOGIN" \
              --arg from "$FROM_DATE" \
              --arg to "$TO_DATE" \
              --argjson n "$N" \
              '{query:$q, variables:{login:$login, from:$from, to:$to, n:$n}}' \
            | curl -sSf -H "Authorization: bearer $GH_TOKEN" \
                    -H "Content-Type: application/json" \
                    -X POST https://api.github.com/graphql \
                    -d @-)

          RESP_FILE=$(mktemp)
          echo "$RESP" > "$RESP_FILE"

          # Fail fast on GraphQL errors (shows details)
          if jq -e '.errors? // [] | length > 0' "$RESP_FILE" > /dev/null; then
            echo "GitHub GraphQL returned errors:" >&2
            jq -r '.errors[] | "- \(.message)"' "$RESP_FILE" >&2
            jq -r '.errors[0]' "$RESP_FILE" >&2
            exit 1
          fi

          # Flatten all repositories from the four buckets
          jq -c '
            .data.user as $u
            | ($u.contributionsCollection // {}) as $c
            | [
                ($c.commitContributionsByRepository // [])[]?.repository,
                ($c.pullRequestContributionsByRepository // [])[]?.repository,
                ($c.issueContributionsByRepository // [])[]?.repository,
                ($c.repositoryContributions.nodes // [])[]?.repository
              ]
            | map(select(. != null))
            ' "$RESP_FILE" > all_repos.json

          # Configs
          INCLUDE_PRIVATE=${INCLUDE_PRIVATE:-false}
          LIMIT=${LIMIT:-30}
          ME=$(jq -r '.data.user.login' "$RESP_FILE")

          # Filter out own repos, optionally drop private, then unique & sort
          if [ "$INCLUDE_PRIVATE" = "true" ]; then
            PRIV_FILTER='.'
          else
            PRIV_FILTER='select(.isPrivate|not)'
          fi

          jq -s '
            (.[0] // [])
            | map('"$PRIV_FILTER"')
            | map(select(.owner.login != "'"$ME"'"))      # exclude your own repos
            | unique_by(.nameWithOwner)
            | sort_by(.lastContribution | fromdateiso8601? // 0)
            | .[0:'"$LIMIT"']
            | map({nameWithOwner, url})
          ' all_repos.json > contributed_repos.json

          # Render markdown with an icon
          if [ "$(jq length contributed_repos.json)" -eq 0 ]; then
            echo "- No public contributions found in the last 12 months." > contributed_repos.md
          else
            jq -r 'map("- ðŸ“„ [\(.nameWithOwner)](\(.url))") | .[]' contributed_repos.json > contributed_repos.md
          fi


      - name: Update README between markers
        run: |
          awk 'BEGIN{p=1}
               /<!-- CONTRIBUTED_REPOS:START -->/{print;print "";system("cat contributed_repos.md");p=0;next}
               /<!-- CONTRIBUTED_REPOS:END -->/{p=1}
               p' README.md > README.new
          mv README.new README.md

      - name: Commit & push
        run: |
          if ! git diff --quiet; then
            git config user.name "${{ github.actor }}"
            git config user.email "${{ github.actor }}@users.noreply.github.com"
            git add README.md contributed_repos*.json contributed_repos.md
            git commit -m "chore: update contributed repos section"
            git push
          fi