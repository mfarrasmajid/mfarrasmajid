name: Update contributed repos in README

on:
  workflow_dispatch:
  schedule:
    - cron: "0 0 * * 1" # every Monday 00:00 UTC â€” adjust as you like

permissions:
  contents: write

jobs:
  update:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Build contributed repos list (last 12 months)
        env:
          GH_LOGIN: ${{ github.repository_owner }}
          # Use CONTRIBS_TOKEN if you want to include private repos (see notes below),
          # otherwise the default GITHUB_TOKEN is fine for public contributions.
          GH_TOKEN: ${{ secrets.CONTRIBS_TOKEN || github.token }}
        run: |
          set -Eeuo pipefail

          # Better error visibility
          trap 'echo "::error file=${BASH_SOURCE[0]},line=${LINENO}::Command failed: $BASH_COMMAND"' ERR

          FROM_DATE="$(date -u -d '1 year ago' +%Y-%m-%dT%H:%M:%SZ)"
          TO_DATE="$(date -u +%Y-%m-%dT%H:%M:%SZ)"
          PAGE_SIZE=100

          read -r -d '' QUERY <<'GRAPHQL'
          query($login:String!, $from:DateTime!, $to:DateTime!, $first:Int!, $after:String) {
            user(login:$login) {
              contributionsCollection(from:$from, to:$to) {
                repositoriesContributedTo(
                  first:$first,
                  after:$after,
                  includeUserRepositories:false,
                  contributionTypes:[COMMIT, PULL_REQUEST, ISSUE, REPOSITORY]
                ) {
                  nodes {
                    nameWithOwner
                    url
                    isPrivate
                  }
                  pageInfo {
                    hasNextPage
                    endCursor
                  }
                }
              }
            }
          }
          GRAPHQL

          # Start fresh
          : > contributed_repos_raw.json

          AFTER=null
          while : ; do
            # Build JSON body locally with jq (avoids quoting mistakes)
            BODY=$(jq -n --arg q "$QUERY" \
                        --arg login "$GH_LOGIN" \
                        --arg from "$FROM_DATE" \
                        --arg to "$TO_DATE" \
                        --argjson first "$PAGE_SIZE" \
                        --argjson after "$AFTER" \
                        '{query:$q, variables:{login:$login, from:$from, to:$to, first:$first, after:$after}}')

            # Use --fail-with-body so non-2xx prints the error message
            RESP=$(curl -sS --fail-with-body \
                -H "Authorization: Bearer $GH_TOKEN" \
                -H "Content-Type: application/json" \
                -X POST https://api.github.com/graphql \
                -d "$BODY")

            # If GraphQL returned errors, show them and exit
            if jq -e '.errors' >/dev/null 2>&1 <<<"$RESP"; then
              echo "GraphQL errors:"
              echo "$RESP" | jq '.errors'
              exit 1
            fi

            # Append nodes (guarded; will no-op if path missing)
            echo "$RESP" \
              | jq -c '.data?.user?.contributionsCollection?.repositoriesContributedTo?.nodes[]?' \
              >> contributed_repos_raw.json

            HAS_NEXT=$(jq -r '.data?.user?.contributionsCollection?.repositoriesContributedTo?.pageInfo?.hasNextPage // false' <<<"$RESP")
            if [ "$HAS_NEXT" != "true" ]; then
              break
            fi

            # endCursor -> JSON string for --argjson (or null if absent)
            AFTER=$(jq -r '.data?.user?.contributionsCollection?.repositoriesContributedTo?.pageInfo?.endCursor' <<<"$RESP")
            if [ -z "$AFTER" ] || [ "$AFTER" = "null" ]; then
              AFTER=null
            else
              AFTER=$(jq -n --arg c "$AFTER" '$c')  # produces a JSON string
            fi
          done

          INCLUDE_PRIVATE=${INCLUDE_PRIVATE:-false}
          if [ "$INCLUDE_PRIVATE" = "true" ]; then
            JQ_FILTER='.'
          else
            JQ_FILTER='select(.isPrivate|not)'
          end

          # Build the final list
          jq -s "[ .[] | $JQ_FILTER | {nameWithOwner, url} ]
                | unique_by(.nameWithOwner)
                | sort_by(.nameWithOwner)" contributed_repos_raw.json > contributed_repos.json

          LIMIT=${LIMIT:-30}
          jq -r ".[0:$LIMIT] | map(\"- [\(.nameWithOwner)](\(.url))\") | .[]" contributed_repos.json > contributed_repos.md

          # Fallback if empty
          if [ ! -s contributed_repos.md ]; then
            echo "- No public contributions found in the last 12 months." > contributed_repos.md
          fi


      - name: Update README between markers
        run: |
          awk 'BEGIN{p=1}
               /<!-- CONTRIBUTED_REPOS:START -->/{print;print "";system("cat contributed_repos.md");p=0;next}
               /<!-- CONTRIBUTED_REPOS:END -->/{p=1}
               p' README.md > README.new
          mv README.new README.md

      - name: Commit & push
        run: |
          if ! git diff --quiet; then
            git config user.name "${{ github.actor }}"
            git config user.email "${{ github.actor }}@users.noreply.github.com"
            git add README.md contributed_repos*.json contributed_repos.md
            git commit -m "chore: update contributed repos section"
            git push
          fi